package proxy

import (
	"crypto/tls"
	"hash/fnv"
	"sync"
)

// ShardedCertCache is a thread-safe certificate cache with sharded locks
// to reduce lock contention under high concurrency.
type ShardedCertCache struct {
	shards []*certCacheShard
}

// certCacheShard represents a single shard of the certificate cache.
type certCacheShard struct {
	cache      map[string]*tls.Certificate
	waitGroups map[string]*sync.WaitGroup
	cacheMu    sync.RWMutex
	waitMu     sync.RWMutex
}

const numShards = 64 // Power of 2 for efficient modulo operation

// NewShardedCertCache creates a new sharded certificate cache.
func NewShardedCertCache() *ShardedCertCache {
	sc := &ShardedCertCache{
		shards: make([]*certCacheShard, numShards),
	}
	for i := 0; i < numShards; i++ {
		sc.shards[i] = &certCacheShard{
			cache:      make(map[string]*tls.Certificate),
			waitGroups: make(map[string]*sync.WaitGroup),
		}
	}
	return sc
}

// getShard returns the shard for a given host using FNV-1a hash.
func (sc *ShardedCertCache) getShard(host string) *certCacheShard {
	h := fnv.New32a()
	_, _ = h.Write([]byte(host))
	return sc.shards[h.Sum32()%numShards]
}

// Get retrieves a certificate from the cache.
// Returns the certificate and true if found, nil and false otherwise.
func (sc *ShardedCertCache) Get(host string) (*tls.Certificate, bool) {
	shard := sc.getShard(host)
	shard.cacheMu.RLock()
	cert, ok := shard.cache[host]
	shard.cacheMu.RUnlock()
	return cert, ok
}

// Set stores a certificate in the cache.
func (sc *ShardedCertCache) Set(host string, cert *tls.Certificate) {
	shard := sc.getShard(host)
	shard.cacheMu.Lock()
	shard.cache[host] = cert
	shard.cacheMu.Unlock()
}

// GetOrWait checks if a certificate is being generated by another goroutine.
// Returns:
// - cert, true, nil: certificate found in cache
// - nil, true, wg: another goroutine is generating, wait on wg
// - nil, false, nil: no certificate and no one is generating
func (sc *ShardedCertCache) GetOrWait(host string) (*tls.Certificate, bool, *sync.WaitGroup) {
	shard := sc.getShard(host)

	// First check cache
	shard.cacheMu.RLock()
	cert, ok := shard.cache[host]
	shard.cacheMu.RUnlock()
	if ok {
		return cert, true, nil
	}

	// Check if someone is generating
	shard.waitMu.RLock()
	wg, isGenerating := shard.waitGroups[host]
	shard.waitMu.RUnlock()

	if isGenerating {
		return nil, true, wg
	}

	return nil, false, nil
}

// StartGeneration marks that this goroutine is generating a certificate for the host.
// Returns a wait group that should be signaled when generation completes.
// Returns nil if another goroutine already started generation.
func (sc *ShardedCertCache) StartGeneration(host string) *sync.WaitGroup {
	shard := sc.getShard(host)

	shard.waitMu.Lock()
	defer shard.waitMu.Unlock()

	// Check if someone else started while we were acquiring the lock
	if _, exists := shard.waitGroups[host]; exists {
		return nil
	}

	wg := &sync.WaitGroup{}
	wg.Add(1)
	shard.waitGroups[host] = wg
	return wg
}

// FinishGeneration cleans up the wait group after certificate generation.
func (sc *ShardedCertCache) FinishGeneration(host string) {
	shard := sc.getShard(host)
	shard.waitMu.Lock()
	delete(shard.waitGroups, host)
	shard.waitMu.Unlock()
}

// SetWithLock stores a certificate while holding the write lock.
// This should be used during certificate generation to avoid race conditions.
// Returns true if the certificate was set, false if another goroutine already set it.
func (sc *ShardedCertCache) SetWithLock(host string, cert *tls.Certificate) bool {
	shard := sc.getShard(host)
	shard.cacheMu.Lock()
	defer shard.cacheMu.Unlock()

	// Check if another goroutine already generated it
	if existingCert, ok := shard.cache[host]; ok {
		// Already exists, don't overwrite
		_ = existingCert
		return false
	}

	shard.cache[host] = cert
	return true
}
